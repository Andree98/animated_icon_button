// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'unions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AnimationDirectionTearOff {
  const _$AnimationDirectionTearOff();

  _Forward forward() {
    return const _Forward();
  }

  _Reverse reverse() {
    return const _Reverse();
  }

  _Bounce bounce() {
    return const _Bounce();
  }
}

/// @nodoc
const $AnimationDirection = _$AnimationDirectionTearOff();

/// @nodoc
mixin _$AnimationDirection {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() forward,
    required TResult Function() reverse,
    required TResult Function() bounce,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? forward,
    TResult Function()? reverse,
    TResult Function()? bounce,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Forward value) forward,
    required TResult Function(_Reverse value) reverse,
    required TResult Function(_Bounce value) bounce,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Forward value)? forward,
    TResult Function(_Reverse value)? reverse,
    TResult Function(_Bounce value)? bounce,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimationDirectionCopyWith<$Res> {
  factory $AnimationDirectionCopyWith(
          AnimationDirection value, $Res Function(AnimationDirection) then) =
      _$AnimationDirectionCopyWithImpl<$Res>;
}

/// @nodoc
class _$AnimationDirectionCopyWithImpl<$Res>
    implements $AnimationDirectionCopyWith<$Res> {
  _$AnimationDirectionCopyWithImpl(this._value, this._then);

  final AnimationDirection _value;
  // ignore: unused_field
  final $Res Function(AnimationDirection) _then;
}

/// @nodoc
abstract class _$ForwardCopyWith<$Res> {
  factory _$ForwardCopyWith(_Forward value, $Res Function(_Forward) then) =
      __$ForwardCopyWithImpl<$Res>;
}

/// @nodoc
class __$ForwardCopyWithImpl<$Res>
    extends _$AnimationDirectionCopyWithImpl<$Res>
    implements _$ForwardCopyWith<$Res> {
  __$ForwardCopyWithImpl(_Forward _value, $Res Function(_Forward) _then)
      : super(_value, (v) => _then(v as _Forward));

  @override
  _Forward get _value => super._value as _Forward;
}

/// @nodoc
class _$_Forward implements _Forward {
  const _$_Forward();

  @override
  String toString() {
    return 'AnimationDirection.forward()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Forward);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() forward,
    required TResult Function() reverse,
    required TResult Function() bounce,
  }) {
    return forward();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? forward,
    TResult Function()? reverse,
    TResult Function()? bounce,
    required TResult orElse(),
  }) {
    if (forward != null) {
      return forward();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Forward value) forward,
    required TResult Function(_Reverse value) reverse,
    required TResult Function(_Bounce value) bounce,
  }) {
    return forward(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Forward value)? forward,
    TResult Function(_Reverse value)? reverse,
    TResult Function(_Bounce value)? bounce,
    required TResult orElse(),
  }) {
    if (forward != null) {
      return forward(this);
    }
    return orElse();
  }
}

abstract class _Forward implements AnimationDirection {
  const factory _Forward() = _$_Forward;
}

/// @nodoc
abstract class _$ReverseCopyWith<$Res> {
  factory _$ReverseCopyWith(_Reverse value, $Res Function(_Reverse) then) =
      __$ReverseCopyWithImpl<$Res>;
}

/// @nodoc
class __$ReverseCopyWithImpl<$Res>
    extends _$AnimationDirectionCopyWithImpl<$Res>
    implements _$ReverseCopyWith<$Res> {
  __$ReverseCopyWithImpl(_Reverse _value, $Res Function(_Reverse) _then)
      : super(_value, (v) => _then(v as _Reverse));

  @override
  _Reverse get _value => super._value as _Reverse;
}

/// @nodoc
class _$_Reverse implements _Reverse {
  const _$_Reverse();

  @override
  String toString() {
    return 'AnimationDirection.reverse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Reverse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() forward,
    required TResult Function() reverse,
    required TResult Function() bounce,
  }) {
    return reverse();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? forward,
    TResult Function()? reverse,
    TResult Function()? bounce,
    required TResult orElse(),
  }) {
    if (reverse != null) {
      return reverse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Forward value) forward,
    required TResult Function(_Reverse value) reverse,
    required TResult Function(_Bounce value) bounce,
  }) {
    return reverse(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Forward value)? forward,
    TResult Function(_Reverse value)? reverse,
    TResult Function(_Bounce value)? bounce,
    required TResult orElse(),
  }) {
    if (reverse != null) {
      return reverse(this);
    }
    return orElse();
  }
}

abstract class _Reverse implements AnimationDirection {
  const factory _Reverse() = _$_Reverse;
}

/// @nodoc
abstract class _$BounceCopyWith<$Res> {
  factory _$BounceCopyWith(_Bounce value, $Res Function(_Bounce) then) =
      __$BounceCopyWithImpl<$Res>;
}

/// @nodoc
class __$BounceCopyWithImpl<$Res> extends _$AnimationDirectionCopyWithImpl<$Res>
    implements _$BounceCopyWith<$Res> {
  __$BounceCopyWithImpl(_Bounce _value, $Res Function(_Bounce) _then)
      : super(_value, (v) => _then(v as _Bounce));

  @override
  _Bounce get _value => super._value as _Bounce;
}

/// @nodoc
class _$_Bounce implements _Bounce {
  const _$_Bounce();

  @override
  String toString() {
    return 'AnimationDirection.bounce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Bounce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() forward,
    required TResult Function() reverse,
    required TResult Function() bounce,
  }) {
    return bounce();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? forward,
    TResult Function()? reverse,
    TResult Function()? bounce,
    required TResult orElse(),
  }) {
    if (bounce != null) {
      return bounce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Forward value) forward,
    required TResult Function(_Reverse value) reverse,
    required TResult Function(_Bounce value) bounce,
  }) {
    return bounce(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Forward value)? forward,
    TResult Function(_Reverse value)? reverse,
    TResult Function(_Bounce value)? bounce,
    required TResult orElse(),
  }) {
    if (bounce != null) {
      return bounce(this);
    }
    return orElse();
  }
}

abstract class _Bounce implements AnimationDirection {
  const factory _Bounce() = _$_Bounce;
}
